[int internal] https://rushter.com/blog/python-integer-implementation/


* int in python is using `bignum` underhood so python can store arbitarily long integers

* random.random() is example of Uniform Distributions 
  (i.e equal probability for all outcomes)

* Fastest way to loop in python is to not use loop & use formulas if available
  if not then consider order -> numpy -> builtins -> for loop -> while loop

* `+=` when used with mutable types such as `list` will perform inplace operation i.e `iconcat()`

* use Fraction when you want to gist out something like stroy from result (i.e like probability or else)

* leading zeros in decimal integer literals are not permitted
  i.e 07 is invalid

* this module ie `import this`

* antigravity module ie `import antigravity`  [open comic book]

* To see underlying representation of num in bits use `struct` module/library : struct.pack()

* decimal.localcontext -> to change context settings for decimal module

* Inorder to get str obj from eval() in python :- use eval(repr(s)) // s is str obj 
  so instead of eval(s) => use eval(repr(s))

* heapq lets you fetch top t of n items in O(t+n) time

* To list all objects in builtin namespace :- dir(__builtins__)

--------

-> for loop is faster in compare to while loop 
   because for loop utilise range() which is iterator written in C underhood 
   whereas in while we have to do increment of cntr manually which is accounted in python itself so it's bit slow
-> use builtin function wherever possible instead of for loop or while loop 

=> If possible than use numpy as entire operations are written in C & its much faster

=> `nan` is the only object which on comparing itself gives False every time

-------- Amazing 

Augmented Assignments Operator :
-----------------------------

-> `+=` behaviour in python
        - It may call __iadd__() or __iconcat__() on calling object 

        Now when you call += on list lying inside tuple it will behave abruptly

    plus equals -> may change pointer to variable (in case of immutable obj)
                -> do inplace operation for mutable objects


-> __name__ == __main__  : Standalone Script
    
    If you see this in python file then you can run it as script 
    otherwise
    Connsider that file as ann library  (Unspoken truth)

    __main__ check allows you to create an entry point of an program that will not 
             work or point will be closed for other scripts

-> int() rounds towards 0 
   whereas division via `//` is same as floor() result 
    
   So When we have -ve result in division int() will perform Ceil whereas // will perform floor() always

-> `/` is used in function param to signnify end of positional arguments

=> To get the info regarding any function call in python you can usen :- cprofile.run 


* Tricky Assignments :
  ----------
   Ellipsis :- ...

   Whenn you do chain assignments in python -> a temp var is created for val expression
    & then all variable from left to right are assigned that temp variable one by one